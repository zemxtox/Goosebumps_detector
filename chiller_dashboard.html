<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <meta name="theme-color" content="#013D5A">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="description" content="Advanced goosebumps detection with real-time analytics">
  <title>CHILLER - Advanced Goosebumps Detector</title>
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json">
  <link rel="icon" href="/icons/icon-192x192.png" type="image/png">
  <link rel="apple-touch-icon" href="/icons/icon-192x192.png">
  
  <!-- Modern Libraries -->
  <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  
  <!-- Tailwind CSS for better responsive design -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <style>
    :root {
      --primary: #013D5A;
      --secondary: #FCF3E3;
      --accent: #F4A258;
      --success: #10B981;
      --warning: #F59E0B;
      --error: #EF4444;
      --surface: rgba(255, 255, 255, 0.05);
      --glass: rgba(255, 255, 255, 0.1);
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, var(--primary) 0%, #0A4B6B 100%);
      color: white;
      min-height: 100vh;
      overflow-x: hidden;
    }
    
    /* Glass morphism effects */
    .glass {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
    }
    
    .glass-strong {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(30px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
    }
    
    /* Custom scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb {
      background: var(--accent);
      border-radius: 4px;
    }
    
    /* Animations */
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    @keyframes glow {
      0%, 100% { box-shadow: 0 0 20px rgba(244, 162, 88, 0.3); }
      50% { box-shadow: 0 0 30px rgba(244, 162, 88, 0.6); }
    }
    
    .animate-fade-in {
      animation: fadeInUp 0.6s ease-out;
    }
    
    .animate-pulse {
      animation: pulse 2s infinite;
    }
    
    .animate-glow {
      animation: glow 2s infinite;
    }
    
    /* Button styles */
    .btn {
      @apply px-6 py-3 rounded-xl font-semibold transition-all duration-300 transform hover:scale-105 active:scale-95;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }
    
    .btn-primary {
      background: linear-gradient(135deg, var(--accent) 0%, #E07A5F 100%);
      color: white;
    }
    
    .btn-primary:hover {
      box-shadow: 0 8px 25px rgba(244, 162, 88, 0.4);
    }
    
    .btn-secondary {
      background: var(--glass);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
    }
    
    .btn-success {
      background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
      color: white;
    }
    
    /* Card styles */
    .card {
      @apply glass p-6 transition-all duration-300 hover:shadow-2xl;
    }
    
    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
    }
    
    /* Status indicators */
    .status-dot {
      @apply w-3 h-3 rounded-full;
    }
    
    .status-active {
      background: var(--success);
      box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
    }
    
    .status-inactive {
      background: var(--error);
      box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
    }
    
    .status-baseline {
      background: var(--warning);
      box-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
    }
    
    /* Video container improvements */
    .video-container {
      @apply relative rounded-2xl overflow-hidden glass-strong;
      aspect-ratio: 16/9;
      max-width: 800px;
    }
    
    .video-container video {
      @apply w-full h-full object-cover;
    }
    
    /* Chart container */
    .chart-container {
      @apply glass p-4 rounded-2xl;
      min-height: 300px;
    }
    
    /* Mobile optimizations */
    @media (max-width: 768px) {
      .video-container {
        aspect-ratio: 4/3;
      }
      
      .btn {
        @apply px-4 py-2 text-sm;
      }
      
      .card {
        @apply p-4;
      }
    }
    
    /* Loading states */
    .loading {
      @apply animate-pulse;
    }
    
    .skeleton {
      background: linear-gradient(90deg, rgba(255,255,255,0.1) 25%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0.1) 75%);
      background-size: 200% 100%;
      animation: loading 1.5s infinite;
    }
    
    @keyframes loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    
    /* Performance indicators */
    .perf-indicator {
      @apply absolute top-2 right-2 px-2 py-1 text-xs rounded-lg;
      background: rgba(0, 0, 0, 0.7);
      font-family: 'Monaco', 'Menlo', monospace;
    }
    
    /* Detection overlay */
    .detection-overlay {
      @apply absolute inset-0 flex items-center justify-center;
      background: rgba(244, 162, 88, 0.2);
      backdrop-filter: blur(2px);
    }
    
    .detection-badge {
      @apply px-4 py-2 rounded-full font-bold text-white animate-glow;
      background: linear-gradient(135deg, var(--accent) 0%, #E07A5F 100%);
    }
  </style>
</head>

<body class="bg-gradient-to-br from-blue-900 to-blue-800">
  <!-- Header -->
  <header class="glass-strong mx-4 mt-4 p-6 animate-fade-in">
    <div class="flex flex-col md:flex-row items-center justify-between">
      <div class="text-center md:text-left mb-4 md:mb-0">
        <h1 class="text-3xl md:text-4xl font-bold bg-gradient-to-r from-orange-400 to-orange-600 bg-clip-text text-transparent">
          ‚ùÑÔ∏è CHILLER Pro
        </h1>
        <p class="text-blue-200 mt-2">Advanced Goosebumps Detection & Analytics</p>
      </div>
      
      <div class="flex items-center space-x-4">
        <div id="connectionStatus" class="flex items-center space-x-2">
          <div class="status-dot status-active"></div>
          <span class="text-sm">Connected</span>
        </div>
        <button id="installBtn" class="btn btn-primary hidden">
          üì± Install App
        </button>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <main class="container mx-auto px-4 py-6 space-y-6">
    
    <!-- Camera Controls -->
    <section class="glass p-6 animate-fade-in">
      <h2 class="text-xl font-semibold mb-4 flex items-center">
        <span class="mr-2">üìπ</span> Camera & Upload
      </h2>
      
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
        <button id="cameraBtn" class="btn btn-primary w-full">
          <span class="mr-2">üì∑</span> Start Camera Detection
        </button>
        
        <label class="btn btn-secondary w-full cursor-pointer">
          <span class="mr-2">üì§</span> Upload Video
          <input type="file" id="videoUpload" accept="video/*" class="hidden">
        </label>
      </div>
    </section>

    <!-- Video Display -->
    <section id="videoSection" class="hidden animate-fade-in">
      <div class="video-container mx-auto">
        <video id="videoElement" autoplay playsinline muted></video>
        
        <!-- Video Overlay -->
        <div id="videoOverlay" class="absolute inset-0">
          <!-- Performance Info -->
          <div class="perf-indicator">
            <div id="fpsCounter">FPS: --</div>
            <div id="frameCounter">Frame: --</div>
          </div>
          
          <!-- Controls -->
          <div class="absolute top-4 left-4 flex space-x-2">
            <button id="closeVideoBtn" class="btn btn-secondary !p-2">‚úï</button>
            <button id="flashlightBtn" class="btn btn-secondary !p-2">üí°</button>
          </div>
          
          <!-- Detection Status -->
          <div id="detectionStatus" class="absolute bottom-4 left-4 px-3 py-2 rounded-lg bg-black bg-opacity-50">
            <span class="text-sm">Initializing...</span>
          </div>
        </div>
      </div>
    </section>

    <!-- Real-time Analytics -->
    <section class="grid grid-cols-1 lg:grid-cols-2 gap-6">
      
      <!-- Live Chart -->
      <div class="card">
        <h3 class="text-lg font-semibold mb-4 flex items-center">
          <span class="mr-2">üìä</span> Real-time Intensity
        </h3>
        <div class="chart-container">
          <div id="liveChart" style="width:100%;height:300px;"></div>
        </div>
      </div>
      
      <!-- Statistics -->
      <div class="card">
        <h3 class="text-lg font-semibold mb-4 flex items-center">
          <span class="mr-2">üìà</span> Statistics
        </h3>
        <div class="grid grid-cols-2 gap-4">
          <div class="glass p-4 rounded-xl text-center">
            <div class="text-2xl font-bold text-orange-400" id="totalDetections">0</div>
            <div class="text-sm text-blue-200">Total Detections</div>
          </div>
          <div class="glass p-4 rounded-xl text-center">
            <div class="text-2xl font-bold text-green-400" id="maxIntensity">0%</div>
            <div class="text-sm text-blue-200">Max Intensity</div>
          </div>
          <div class="glass p-4 rounded-xl text-center">
            <div class="text-2xl font-bold text-blue-400" id="avgIntensity">0%</div>
            <div class="text-sm text-blue-200">Avg Intensity</div>
          </div>
          <div class="glass p-4 rounded-xl text-center">
            <div class="text-2xl font-bold text-purple-400" id="activeDevices">0</div>
            <div class="text-sm text-blue-200">Active Devices</div>
          </div>
        </div>
      </div>
    </section>

    <!-- Device Management -->
    <section class="card">
      <div class="flex flex-col md:flex-row items-start md:items-center justify-between mb-6">
        <h3 class="text-lg font-semibold flex items-center mb-4 md:mb-0">
          <span class="mr-2">üîß</span> Device Management
        </h3>
        
        <div class="flex flex-col md:flex-row space-y-2 md:space-y-0 md:space-x-4">
          <select id="deviceSelect" class="glass px-4 py-2 rounded-lg border-0 text-white">
            <option value="__all__">All Devices</option>
          </select>
          
          <div class="flex space-x-2">
            <button id="resetBtn" class="btn btn-secondary">üîÑ Reset</button>
            <button id="exportBtn" class="btn btn-success">üíæ Export</button>
          </div>
        </div>
      </div>
      
      <!-- Device Grid -->
      <div id="deviceGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        <!-- Device cards will be inserted here -->
      </div>
    </section>

  </main>

  <!-- Loading Overlay -->
  <div id="loadingOverlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
    <div class="glass p-8 rounded-2xl text-center">
      <div class="animate-spin w-12 h-12 border-4 border-orange-400 border-t-transparent rounded-full mx-auto mb-4"></div>
      <p class="text-lg">Processing...</p>
    </div>
  </div>

  <!-- Notification Toast -->
  <div id="toast" class="fixed top-4 right-4 glass p-4 rounded-xl transform translate-x-full transition-transform duration-300 z-50">
    <div id="toastMessage" class="text-sm"></div>
  </div>

  <script>
    // Enhanced Application State Management
    class ChillerApp {
      constructor() {
        this.socket = io();
        this.devices = new Map();
        this.currentStream = null;
        this.isProcessing = false;
        this.stats = {
          totalDetections: 0,
          maxIntensity: 0,
          avgIntensity: 0,
          activeDevices: 0
        };
        
        // Performance tracking
        this.performance = {
          fps: 0,
          frameCount: 0,
          lastFrameTime: 0,
          processingTimes: []
        };
        
        // Initialize Plotly chart
        this.initializeLiveChart();
        this.setupEventListeners();
        this.setupSocketHandlers();
        this.checkDeviceCapabilities();
      }
      
      // Initialize advanced Plotly chart
      initializeLiveChart() {
        const layout = {
          title: {
            text: 'Goosebump Intensity Over Time',
            font: { color: 'white', size: 16 }
          },
          xaxis: {
            title: 'Time',
            color: 'white',
            gridcolor: 'rgba(255,255,255,0.1)',
            type: 'date'
          },
          yaxis: {
            title: 'Intensity (%)',
            color: 'white',
            gridcolor: 'rgba(255,255,255,0.1)',
            range: [-10, 100]
          },
          plot_bgcolor: 'rgba(0,0,0,0)',
          paper_bgcolor: 'rgba(0,0,0,0)',
          font: { color: 'white' },
          margin: { t: 50, r: 20, b: 50, l: 60 }
        };
        
        const config = {
          responsive: true,
          displayModeBar: false
        };
        
        this.chartData = [{
          x: [],
          y: [],
          type: 'scatter',
          mode: 'lines+markers',
          line: {
            color: '#F4A258',
            width: 3,
            shape: 'spline'
          },
          marker: {
            color: '#F4A258',
            size: 6
          },
          name: 'Intensity'
        }];
        
        Plotly.newPlot('liveChart', this.chartData, layout, config);
      }
      
      // Setup event listeners
      setupEventListeners() {
        // Camera controls
        document.getElementById('cameraBtn').addEventListener('click', () => this.toggleCamera());
        document.getElementById('videoUpload').addEventListener('change', (e) => this.handleVideoUpload(e));
        document.getElementById('closeVideoBtn').addEventListener('click', () => this.stopCamera());
        document.getElementById('flashlightBtn').addEventListener('click', () => this.toggleFlashlight());
        
        // Device management
        document.getElementById('deviceSelect').addEventListener('change', (e) => this.filterDevices(e.target.value));
        document.getElementById('resetBtn').addEventListener('click', () => this.resetBaseline());
        document.getElementById('exportBtn').addEventListener('click', () => this.exportData());
        
        // PWA install
        document.getElementById('installBtn').addEventListener('click', () => this.installPWA());
        
        // Handle PWA install prompt
        window.addEventListener('beforeinstallprompt', (e) => {
          e.preventDefault();
          this.deferredPrompt = e;
          document.getElementById('installBtn').classList.remove('hidden');
        });
      }
      
      // Setup Socket.IO handlers
      setupSocketHandlers() {
        this.socket.on('connect', () => {
          this.updateConnectionStatus(true);
          this.showToast('Connected to server', 'success');
        });
        
        this.socket.on('disconnect', () => {
          this.updateConnectionStatus(false);
          this.showToast('Disconnected from server', 'error');
        });
        
        this.socket.on('frame', (data) => this.handleFrameData(data));
        this.socket.on('devices', (data) => this.updateDeviceList(data.devices || []));
      }
      
      // Check device capabilities
      async checkDeviceCapabilities() {
        // Check for camera support
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          this.showToast('Camera not supported on this device', 'warning');
          document.getElementById('cameraBtn').disabled = true;
        }
        
        // Check for secure context
        if (!window.isSecureContext) {
          this.showToast('Some features require HTTPS', 'warning');
        }
        
        // Load initial device list
        try {
          const response = await fetch('/devices');
          const data = await response.json();
          this.updateDeviceList(data.devices || []);
        } catch (error) {
          console.error('Failed to load devices:', error);
        }
      }
      
      // Camera management
      async toggleCamera() {
        if (this.currentStream) {
          this.stopCamera();
          return;
        }
        
        try {
          this.showLoading(true);
          
          const constraints = {
            video: {
              facingMode: 'environment',
              width: { ideal: 1280, max: 1920 },
              height: { ideal: 720, max: 1080 },
              frameRate: { ideal: 30, max: 60 }
            }
          };
          
          this.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
          const videoElement = document.getElementById('videoElement');
          videoElement.srcObject = this.currentStream;
          
          document.getElementById('videoSection').classList.remove('hidden');
          document.getElementById('cameraBtn').textContent = '‚èπÔ∏è Stop Camera';
          
          // Start processing frames
          videoElement.addEventListener('loadedmetadata', () => {
            this.startFrameProcessing();
            this.showLoading(false);
          });
          
        } catch (error) {
          console.error('Camera error:', error);
          this.showToast(`Camera error: ${error.message}`, 'error');
          this.showLoading(false);
        }
      }
      
      stopCamera() {
        if (this.currentStream) {
          this.currentStream.getTracks().forEach(track => track.stop());
          this.currentStream = null;
        }
        
        const videoElement = document.getElementById('videoElement');
        videoElement.srcObject = null;
        
        document.getElementById('videoSection').classList.add('hidden');
        document.getElementById('cameraBtn').textContent = 'üì∑ Start Camera Detection';
        
        this.isProcessing = false;
      }
      
      // Advanced frame processing with performance optimization
      startFrameProcessing() {
        const videoElement = document.getElementById('videoElement');
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        let frameInterval = 200; // Start with 200ms (5fps)
        const deviceId = `camera-${Date.now()}`;
        
        const processFrame = async () => {
          if (!this.currentStream || this.isProcessing) return;
          
          this.isProcessing = true;
          const startTime = performance.now();
          
          try {
            // Update canvas size to match video
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
            
            // Draw frame
            ctx.drawImage(videoElement, 0, 0);
            
            // Convert to blob with optimized quality
            const blob = await new Promise(resolve => {
              canvas.toBlob(resolve, 'image/jpeg', 0.8);
            });
            
            // Convert to base64
            const base64 = await this.blobToBase64(blob);
            
            // Send to server
            const response = await fetch('/upload_frame', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                device_id: deviceId,
                jpg_b64: base64.split(',')[1],
                frame_number: this.performance.frameCount++
              })
            });
            
            const data = await response.json();
            
            // Update performance metrics
            const processingTime = performance.now() - startTime;
            this.updatePerformanceMetrics(processingTime);
            
            // Adjust frame rate based on performance
            this.adjustFrameRate(processingTime, frameInterval);
            
          } catch (error) {
            console.error('Frame processing error:', error);
          } finally {
            this.isProcessing = false;
            
            // Schedule next frame
            if (this.currentStream) {
              setTimeout(processFrame, frameInterval);
            }
          }
        };
        
        // Start processing
        processFrame();
      }
      
      // Handle incoming frame data
      handleFrameData(data) {
        // Update live chart
        this.updateLiveChart(data);
        
        // Update device card
        this.updateDeviceCard(data);
        
        // Update statistics
        this.updateStatistics(data);
        
        // Update detection status
        this.updateDetectionStatus(data);
      }
      
      // Update live chart with new data
      updateLiveChart(data) {
        if (!data.baseline_established) return;
        
        const now = new Date();
        this.chartData[0].x.push(now);
        this.chartData[0].y.push(data.goosebump_intensity);
        
        // Keep only last 100 points
        if (this.chartData[0].x.length > 100) {
          this.chartData[0].x.shift();
          this.chartData[0].y.shift();
        }
        
        // Update chart
        Plotly.redraw('liveChart');
      }
      
      // Update device card
      updateDeviceCard(data) {
        let deviceCard = document.getElementById(`device-${data.device_id}`);
        
        if (!deviceCard) {
          deviceCard = this.createDeviceCard(data.device_id);
        }
        
        // Update image
        const img = deviceCard.querySelector('.device-image');
        if (img && data.img) {
          img.src = `data:image/jpeg;base64,${data.img}`;
        }
        
        // Update status
        const status = deviceCard.querySelector('.device-status');
        if (status) {
          if (!data.baseline_established) {
            status.textContent = 'Recording Baseline';
            status.className = 'device-status px-2 py-1 rounded text-xs bg-yellow-500';
          } else if (data.detect) {
            status.textContent = `Goosebumps! ${data.goosebump_intensity.toFixed(1)}%`;
            status.className = 'device-status px-2 py-1 rounded text-xs bg-red-500 animate-pulse';
          } else {
            status.textContent = 'Monitoring';
            status.className = 'device-status px-2 py-1 rounded text-xs bg-green-500';
          }
        }
        
        // Update metrics
        const metrics = deviceCard.querySelectorAll('.metric-value');
        if (metrics.length >= 3) {
          metrics[0].textContent = data.detection_count;
          metrics[1].textContent = data.goosebump_intensity.toFixed(1) + '%';
          metrics[2].textContent = data.frame_number;
        }
      }
      
      // Create device card
      createDeviceCard(deviceId) {
        const grid = document.getElementById('deviceGrid');
        const card = document.createElement('div');
        card.id = `device-${deviceId}`;
        card.className = 'card animate-fade-in';
        
        card.innerHTML = `
          <div class="flex items-center justify-between mb-4">
            <h4 class="font-semibold truncate">${deviceId}</h4>
            <div class="status-dot status-active"></div>
          </div>
          
          <div class="aspect-video bg-black rounded-lg mb-4 overflow-hidden">
            <img class="device-image w-full h-full object-cover" alt="Device feed">
          </div>
          
          <div class="device-status px-2 py-1 rounded text-xs bg-gray-500 mb-4">
            Initializing...
          </div>
          
          <div class="grid grid-cols-3 gap-2 text-center">
            <div>
              <div class="metric-value text-lg font-bold text-orange-400">0</div>
              <div class="text-xs text-gray-300">Detections</div>
            </div>
            <div>
              <div class="metric-value text-lg font-bold text-green-400">0%</div>
              <div class="text-xs text-gray-300">Intensity</div>
            </div>
            <div>
              <div class="metric-value text-lg font-bold text-blue-400">0</div>
              <div class="text-xs text-gray-300">Frames</div>
            </div>
          </div>
          
          <div class="flex space-x-2 mt-4">
            <button class="btn btn-secondary flex-1 !py-1 !text-xs" onclick="app.resetDevice('${deviceId}')">
              Reset
            </button>
            <button class="btn btn-success flex-1 !py-1 !text-xs" onclick="app.exportDevice('${deviceId}')">
              Export
            </button>
          </div>
        `;
        
        grid.appendChild(card);
        return card;
      }
      
      // Update statistics
      updateStatistics(data) {
        if (data.detect) {
          this.stats.totalDetections++;
        }
        
        if (data.goosebump_intensity > this.stats.maxIntensity) {
          this.stats.maxIntensity = data.goosebump_intensity;
        }
        
        // Update DOM
        document.getElementById('totalDetections').textContent = this.stats.totalDetections;
        document.getElementById('maxIntensity').textContent = this.stats.maxIntensity.toFixed(1) + '%';
        document.getElementById('activeDevices').textContent = this.devices.size;
      }
      
      // Update performance metrics
      updatePerformanceMetrics(processingTime) {
        this.performance.processingTimes.push(processingTime);
        
        // Keep only last 30 measurements
        if (this.performance.processingTimes.length > 30) {
          this.performance.processingTimes.shift();
        }
        
        // Calculate FPS
        const now = performance.now();
        if (this.performance.lastFrameTime) {
          const frameDelta = now - this.performance.lastFrameTime;
          this.performance.fps = 1000 / frameDelta;
        }
        this.performance.lastFrameTime = now;
        
        // Update UI
        document.getElementById('fpsCounter').textContent = `FPS: ${this.performance.fps.toFixed(1)}`;
        document.getElementById('frameCounter').textContent = `Frame: ${this.performance.frameCount}`;
      }
      
      // Utility functions
      async blobToBase64(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      }
      
      showToast(message, type = 'info') {
        const toast = document.getElementById('toast');
        const toastMessage = document.getElementById('toastMessage');
        
        toastMessage.textContent = message;
        toast.className = `fixed top-4 right-4 glass p-4 rounded-xl transition-transform duration-300 z-50 ${
          type === 'success' ? 'border-green-400' : 
          type === 'error' ? 'border-red-400' : 
          type === 'warning' ? 'border-yellow-400' : 'border-blue-400'
        }`;
        
        toast.style.transform = 'translateX(0)';
        
        setTimeout(() => {
          toast.style.transform = 'translateX(100%)';
        }, 3000);
      }
      
      showLoading(show) {
        const overlay = document.getElementById('loadingOverlay');
        overlay.classList.toggle('hidden', !show);
      }
      
      updateConnectionStatus(connected) {
        const status = document.getElementById('connectionStatus');
        const dot = status.querySelector('.status-dot');
        const text = status.querySelector('span');
        
        if (connected) {
          dot.className = 'status-dot status-active';
          text.textContent = 'Connected';
        } else {
          dot.className = 'status-dot status-inactive';
          text.textContent = 'Disconnected';
        }
      }
      
      // Device management methods
      updateDeviceList(devices) {
        const select = document.getElementById('deviceSelect');
        const currentValue = select.value;
        
        // Clear existing options except "All Devices"
        select.innerHTML = '<option value="__all__">All Devices</option>';
        
        devices.forEach(device => {
          const option = document.createElement('option');
          option.value = device.id || device;
          option.textContent = `${device.id || device} ${device.baseline_ready ? '‚úì' : '‚è≥'}`;
          select.appendChild(option);
          
          this.devices.set(device.id || device, device);
        });
        
        // Restore selection
        select.value = currentValue;
        
        // Update active devices count
        this.stats.activeDevices = devices.length;
        document.getElementById('activeDevices').textContent = this.stats.activeDevices;
      }
      
      async resetDevice(deviceId) {
        try {
          const response = await fetch(`/reset_baseline/${deviceId}`, { method: 'POST' });
          if (response.ok) {
            this.showToast(`Baseline reset for ${deviceId}`, 'success');
          }
        } catch (error) {
          this.showToast(`Error resetting ${deviceId}`, 'error');
        }
      }
      
      exportDevice(deviceId) {
        // Implementation for exporting device data
        this.showToast(`Exporting data for ${deviceId}`, 'info');
      }
      
      async installPWA() {
        if (this.deferredPrompt) {
          this.deferredPrompt.prompt();
          const { outcome } = await this.deferredPrompt.userChoice;
          
          if (outcome === 'accepted') {
            this.showToast('App installed successfully!', 'success');
          }
          
          this.deferredPrompt = null;
          document.getElementById('installBtn').classList.add('hidden');
        }
      }
    }
    
    // Initialize application
    const app = new ChillerApp();
    
    // Make app globally available for inline event handlers
    window.app = app;
  </script>
</body>
</html>
