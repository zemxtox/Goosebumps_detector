<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <meta name="theme-color" content="#013D5A">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="description" content="A mobile app to detect goosebumps from video or camera">
  <title>Goosebumps Detector</title>
  <link rel="manifest" href="/manifest.json">
  <link rel="icon" href="/icons/icon-192x192.png" type="image/png">
  <link rel="apple-touch-icon" href="/icons/icon-192x192.png">
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.min.js"></script>
  <style>
    :root {
        --midnight: #013D5A;
        --lionsmane: #FCF3E3;
        --celeste: #BDD3CE;
        --herb: #708C69;
        --marigold: #F4A258;
        --success: #4CAF50;
        --danger: #F44336;
        --warning: #FF9800;
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body { 
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
      background: linear-gradient(135deg, var(--midnight) 0%, #025f7a 100%);
      color: white; 
      min-height: 100vh; 
      overflow-x: hidden;
      padding: 1rem;
    }
    
    .container { max-width: 1400px; margin: 0 auto; }
    
    .header { 
      text-align: center; 
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      background: rgba(255, 255, 255, 0.08); 
      backdrop-filter: blur(20px); 
      border-radius: 1rem;
      border: 1px solid rgba(255, 255, 255, 0.12); 
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    }
    
    .header h1 { 
      font-size: clamp(1.5rem, 5vw, 2.5rem);
      font-weight: 800; 
      margin-bottom: 0.5rem;
      background: linear-gradient(135deg, var(--lionsmane) 0%, var(--celeste) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .header p { font-size: clamp(0.875rem, 2vw, 1rem); opacity: 0.9; color: var(--celeste); }
    
    .controls-section {
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(20px);
      border-radius: 1rem;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }
    
    .camera-controls { display: grid; gap: 1rem; grid-template-columns: 1fr; }
    @media (min-width: 640px) { .camera-controls { grid-template-columns: repeat(2, 1fr); } }
    
    .btn { 
      padding: 0.875rem 1.5rem; border: none; border-radius: 0.75rem;
      font-weight: 700; font-size: 0.9375rem; cursor: pointer; 
      transition: all 0.3s ease;
      display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.2);
    }
    .btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-primary { background: linear-gradient(135deg, var(--celeste) 0%, #9fc9c3 100%); color: var(--midnight); }
    .btn-secondary { background: rgba(255, 255, 255, 0.12); color: white; border: 1px solid rgba(255, 255, 255, 0.2); }
    .btn-success { background: linear-gradient(135deg, var(--herb) 0%, #5d7556 100%); color: white; }
    
    .file-upload { display: none; }
    
    .video-container { 
      position: relative; width: 100%; max-width: 800px; 
      margin: 0 auto 1.5rem; background: #000; border-radius: 1rem;
      overflow: hidden; display: none;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4); 
      border: 2px solid rgba(255, 255, 255, 0.15);
    }
    .video-container.active { display: block; }
    .video-container video { width: 100%; height: auto; display: block; }
    
    .camera-overlay { 
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
      display: flex; flex-direction: column; justify-content: space-between; 
      pointer-events: none; 
    }
    .camera-controls-top { display: flex; justify-content: space-between; padding: 1rem; gap: 0.5rem; }
    .camera-btn { 
      background: rgba(0,0,0,0.7); color: white; 
      border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; 
      width: 48px; height: 48px; 
      display: flex; align-items: center; justify-content: center; 
      font-size: 1.25rem; cursor: pointer; pointer-events: auto; 
      transition: all 0.2s ease; backdrop-filter: blur(10px);
    }
    .camera-btn:hover { background: rgba(0,0,0,0.9); transform: scale(1.1); }
    
    .video-info {
      position: absolute; top: 1rem; left: 1rem;
      background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(10px);
      padding: 0.5rem 0.75rem; border-radius: 0.5rem;
      font-size: 0.875rem; border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .detection-badge {
      position: absolute; bottom: 1rem; left: 1rem;
      background: linear-gradient(135deg, var(--success) 0%, #45a049 100%);
      padding: 0.75rem 1rem; border-radius: 0.75rem;
      font-weight: 700; animation: pulse 1.5s ease-in-out infinite;
      box-shadow: 0 4px 16px rgba(76, 175, 80, 0.4);
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.9; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.05); }
    }
    
    .live-graph-container { 
      width: 100%; max-width: 800px; margin: 0 auto 1.5rem;
      background: rgba(255, 255, 255, 0.08); backdrop-filter: blur(20px);
      border-radius: 1rem; padding: 1.5rem; display: none;
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    }
    .live-graph-container.active { display: block; }
    
    .graph-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    
    .graph-title {
      font-size: 1.125rem;
      font-weight: 700;
      color: var(--lionsmane);
    }
    
    .graph-controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    
    .device-selector { text-align: center; margin-bottom: 1.5rem; }
    .device-selector select { 
      background: rgba(255, 255, 255, 0.12); border: 2px solid rgba(255, 255, 255, 0.2); 
      color: white; padding: 0.875rem 1.25rem; border-radius: 0.75rem;
      font-size: 1rem; font-weight: 600; cursor: pointer; 
      min-width: min(300px, 100%); transition: all 0.3s ease;
    }
    .device-selector select:hover { border-color: var(--celeste); background: rgba(255, 255, 255, 0.15); }
    .device-selector select option { background: var(--midnight); color: white; }
    
    .panel { 
      background: rgba(255, 255, 255, 0.08); backdrop-filter: blur(20px); 
      border-radius: 1rem; padding: 1.5rem; margin-bottom: 1.5rem;
      border: 1px solid rgba(255, 255, 255, 0.12); 
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); 
    }
    
    .panel-title { 
      font-size: clamp(1.25rem, 3vw, 1.5rem); font-weight: 700; 
      margin-bottom: 1.25rem; display: flex; align-items: center; 
      gap: 0.75rem; color: var(--lionsmane);
    }
    
    .cards-grid { display: grid; gap: 1.25rem; grid-template-columns: 1fr; }
    @media (min-width: 640px) { .cards-grid { grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); } }
    
    .device-card { 
      background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 1rem; overflow: hidden; display: flex; flex-direction: column;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .device-card:hover { transform: translateY(-4px); box-shadow: 0 12px 32px rgba(0, 0, 0, 0.4); }
    
    .device-card__header { 
      display: flex; align-items: center; justify-content: space-between; 
      padding: 1rem 1.25rem; background: rgba(0, 0, 0, 0.4); 
      border-bottom: 1px solid rgba(255, 255, 255, 0.1); 
    }
    
    .device-card__title-container { display: flex; align-items: center; gap: 0.625rem; }
    .device-card__title { font-weight: 700; font-size: 1rem; letter-spacing: 0.3px; }
    
    .status-indicator { 
      width: 10px; height: 10px; border-radius: 50%; 
      transition: all 0.3s ease; box-shadow: 0 0 8px currentColor;
    }
    .status-indicator.active { background-color: var(--success); }
    .status-indicator.inactive { background-color: var(--danger); }
    
    .device-card__actions { display: flex; gap: 0.5rem; }
    .sm-btn { 
      padding: 0.5rem 0.875rem; border-radius: 0.5rem;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(255, 255, 255, 0.12); color: white;
      font-weight: 600; font-size: 0.8125rem; cursor: pointer; 
      transition: all 0.2s ease;
    }
    .sm-btn:hover { background: rgba(255, 255, 255, 0.2); transform: translateY(-1px); }
    
    .device-card__feed { position: relative; background: #000; height: 200px; overflow: hidden; }
    .device-card__feed img { width: 100%; height: 100%; object-fit: cover; display: block; }
    
    .feed-overlay { 
      position: absolute; top: 0.75rem; left: 0.75rem;
      padding: 0.5rem 1rem; border-radius: 2rem;
      font-size: 0.8125rem; font-weight: 700; 
      border: 1px solid rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(10px);
    }
    .baseline { background: linear-gradient(135deg, var(--marigold) 0%, #e89048 100%); color: white; }
    .monitor { background: rgba(255, 255, 255, 0.2); color: white; }
    .detect { background: linear-gradient(135deg, var(--herb) 0%, #5d7556 100%); color: white; }
    
    .device-card__stats { 
      display: grid; grid-template-columns: repeat(4, 1fr);
      gap: 0.75rem; padding: 1rem 1.25rem; background: rgba(0, 0, 0, 0.2);
    }
    
    .stat { 
      background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 0.75rem; text-align: center; padding: 0.75rem 0.5rem;
      transition: all 0.3s ease;
    }
    .stat:hover { background: rgba(0, 0, 0, 0.4); transform: translateY(-2px); }
    .stat .label { 
      font-size: 0.6875rem; opacity: 0.8; text-transform: uppercase; 
      letter-spacing: 0.5px; color: var(--celeste); margin-bottom: 0.25rem;
    }
    .stat .val { font-size: 1.125rem; font-weight: 800; color: var(--lionsmane); }
    
    .device-card__chart { height: 220px; padding: 1rem; }
    
    .action-controls { display: grid; gap: 1rem; grid-template-columns: 1fr; }
    @media (min-width: 640px) { .action-controls { grid-template-columns: repeat(2, 1fr); } }
    
    .status-message {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 0.75rem;
      border: 2px solid var(--success);
      font-weight: 600;
      display: none;
      z-index: 1000;
      animation: slideIn 0.3s ease;
    }
    
    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>‚ùÑÔ∏è Goosebumps Detector</h1>
      <p>Real-time detection and analysis dashboard</p>
    </div>
    
    <div class="controls-section">
      <div class="camera-controls">
        <button class="btn btn-primary" id="cameraBtn">
          <span>üì∑</span> Detect from Camera
        </button>
        <label class="btn btn-success">
          <span>üì§</span> Upload Video
          <input type="file" class="file-upload" id="videoUpload" accept="video/*">
        </label>
      </div>
    </div>
    
    <div class="video-container" id="videoContainer">
      <video id="videoElement" autoplay playsinline muted></video>
      <div class="camera-overlay">
        <div class="camera-controls-top">
          <button class="camera-btn" id="closeVideoBtn" title="Close">‚úï</button>
          <button class="camera-btn" id="flashlightBtn" title="Flash">üí°</button>
        </div>
      </div>
      <div id="videoInfoOverlay"></div>
    </div>
    
    <div class="live-graph-container" id="liveGraphContainer">
      <div class="graph-header">
        <div class="graph-title">üìä Live Intensity Graph</div>
        <div class="graph-controls">
          <button id="clearGraphBtn" class="sm-btn">Clear</button>
        </div>
      </div>
      <div id="liveGraph" style="width: 100%; height: 300px;"></div>
    </div>
    
    <div class="device-selector">
      <select id="deviceSelect">
        <option value="all">All Active Devices</option>
      </select>
    </div>
    
    <div class="panel">
      <div class="panel-title"><span>üìπ</span> Live Feeds & Statistics</div>
      <div id="cardsGrid" class="cards-grid"></div>
    </div>
    
    <div class="panel">
      <div class="panel-title"><span>‚öôÔ∏è</span> Controls</div>
      <div class="action-controls">
        <button class="btn btn-primary" id="resetBaseline">üîÑ Reset Baseline</button>
        <button class="btn btn-secondary" id="exportData">üíæ Export Data</button>
      </div>
    </div>
  </div>
  
  <div id="statusMessage" class="status-message"></div>

  <script>
    console.log('üöÄ Starting Goosebumps Detector...');
    
    const socket = io();
    let selectedDevice = 'all';
    const deviceCards = new Map();
    const deviceLastActive = new Map();
    
    // Create live chart with proper configuration
    const liveChartOptions = {
      chart: {
        type: 'line',
        height: 300,
        background: 'transparent',
        animations: {
          enabled: true,
          easing: 'linear',
          dynamicAnimation: {
            speed: 500
          }
        },
        toolbar: { show: false },
        zoom: { enabled: false }
      },
      series: [{
        name: 'Intensity',
        data: []
      }],
      stroke: {
        curve: 'straight',
        width: 3,
        colors: ['#ff0000']
      },
      markers: {
        size: 0,
        hover: { size: 6 }
      },
      xaxis: {
        type: 'numeric',
        title: {
          text: 'Frame',
          style: { color: '#FCF3E3', fontSize: '14px', fontWeight: 700 }
        },
        labels: {
          style: { colors: '#BDD3CE' }
        },
        axisBorder: { color: 'rgba(255,255,255,0.2)' }
      },
      yaxis: {
        min: 0,
        max: 100,
        title: {
          text: 'Intensity (%)',
          style: { color: '#FCF3E3', fontSize: '14px', fontWeight: 700 }
        },
        labels: {
          style: { colors: '#BDD3CE' },
          formatter: (val) => val.toFixed(0) + '%'
        }
      },
      grid: {
        borderColor: 'rgba(255,255,255,0.1)',
        strokeDashArray: 3
      },
      tooltip: {
        theme: 'dark',
        x: { show: true },
        y: {
          formatter: (val) => val.toFixed(2) + '%'
        }
      },
      dataLabels: { enabled: false }
    };
    
    console.log('üìä Creating live chart...');
    const liveChart = new ApexCharts(document.getElementById('liveGraph'), liveChartOptions);
    liveChart.render().then(() => {
      console.log('‚úÖ Live chart rendered successfully');
    }).catch(err => {
      console.error('‚ùå Live chart render error:', err);
    });
    
    // Chart options for device cards
    const deviceChartOptions = {
      chart: {
        type: 'line',
        height: 220,
        background: 'transparent',
        animations: {
          enabled: true,
          easing: 'linear',
          dynamicAnimation: { speed: 500 }
        },
        toolbar: { show: false },
        zoom: { enabled: false }
      },
      stroke: {
        curve: 'straight',
        width: 2,
        colors: ['#51cf66']
      },
      markers: { size: 0 },
      xaxis: {
        type: 'numeric',
        labels: { style: { colors: '#BDD3CE', fontSize: '10px' } }
      },
      yaxis: {
        min: 0,
        max: 100,
        labels: {
          style: { colors: '#BDD3CE', fontSize: '10px' },
          formatter: (val) => val.toFixed(0)
        }
      },
      grid: {
        borderColor: 'rgba(255,255,255,0.1)',
        strokeDashArray: 3
      },
      tooltip: {
        theme: 'dark',
        y: { formatter: (val) => val.toFixed(2) + '%' }
      },
      dataLabels: { enabled: false }
    };
    
    function buildCard(id) {
      if (deviceCards.has(id)) return deviceCards.get(id);
      
      console.log('üîß Building card for device:', id);
      const grid = document.getElementById('cardsGrid');
      const card = document.createElement('div');
      card.className = 'device-card';
      card.dataset.device = id;
      
      const header = document.createElement('div');
      header.className = 'device-card__header';
      
      const titleContainer = document.createElement('div');
      titleContainer.className = 'device-card__title-container';
      
      const title = document.createElement('div');
      title.className = 'device-card__title';
      title.textContent = id;
      
      const statusIndicator = document.createElement('div');
      statusIndicator.className = 'status-indicator active';
      
      titleContainer.append(title, statusIndicator);
      
      const actions = document.createElement('div');
      actions.className = 'device-card__actions';
      
      const btnReset = document.createElement('button');
      btnReset.className = 'sm-btn';
      btnReset.textContent = 'Reset';
      btnReset.onclick = () => perDeviceReset(id);
      
      const btnCSV = document.createElement('button');
      btnCSV.className = 'sm-btn';
      btnCSV.textContent = 'Export';
      btnCSV.onclick = () => perDeviceExport(id);
      
      actions.append(btnReset, btnCSV);
      header.append(titleContainer, actions);
      
      const feed = document.createElement('div');
      feed.className = 'device-card__feed';
      const img = document.createElement('img');
      img.alt = 'Feed';
      const overlay = document.createElement('div');
      overlay.className = 'feed-overlay monitor';
      overlay.textContent = 'Initializing...';
      feed.append(img, overlay);
      
      const stats = document.createElement('div');
      stats.className = 'device-card__stats';
      const s1 = statBox('Baseline');
      const s2 = statBox('Power');
      const s3 = statBox('Detects');
      const s4 = statBox('Frames');
      stats.append(s1.root, s2.root, s3.root, s4.root);
      
      const chartWrap = document.createElement('div');
      chartWrap.className = 'device-card__chart';
      const chartId = 'chart-' + id.replace(/[^a-zA-Z0-9]/g, '_');
      chartWrap.id = chartId;
      
      card.append(header, feed, stats, chartWrap);
      grid.appendChild(card);
      
      // Create chart
      const chart = new ApexCharts(document.getElementById(chartId), {
        ...deviceChartOptions,
        series: [{ name: 'Intensity', data: [] }]
      });
      
      chart.render().then(() => {
        console.log('‚úÖ Chart rendered for device:', id);
      }).catch(err => {
        console.error('‚ùå Chart render error for device', id, ':', err);
      });
      
      const entry = {
        root: card,
        img: img,
        overlay: overlay,
        stats: { baseline: s1, power: s2, detect: s3, frames: s4 },
        chart: chart,
        detections: []
      };
      
      deviceCards.set(id, entry);
      return entry;
    }
    
    function statBox(label) {
      const root = document.createElement('div');
      root.className = 'stat';
      const l = document.createElement('div');
      l.className = 'label';
      l.textContent = label;
      const v = document.createElement('div');
      v.className = 'val';
      v.textContent = '--';
      root.append(l, v);
      return {
        root: root,
        labelEl: l,
        valEl: v,
        set: (x) => v.textContent = x
      };
    }
    
    function applyFilter() {
      deviceCards.forEach(({ root }, id) => {
        if (selectedDevice === 'all') {
          root.style.display = 'flex';
        } else {
          root.style.display = (id === selectedDevice) ? 'flex' : 'none';
        }
      });
    }
    
    async function perDeviceReset(id) {
      try {
        const r = await fetch('/reset_baseline/' + id, { method: 'POST' });
        if (r.ok) {
          showStatus('‚úÖ Baseline reset for ' + id);
        }
      } catch (e) {
        showStatus('‚ùå Error: ' + e.message);
      }
    }
    
    function perDeviceExport(id) {
      const entry = deviceCards.get(id);
      if (!entry || entry.detections.length === 0) {
        showStatus('‚ùå No detections to export!');
        return;
      }
      const csv = 'Device,Time,Frame,Intensity\n' + 
        entry.detections.map(d => id + ',' + d.time + ',' + d.frame + ',' + d.intensity).join('\n');
      downloadCSV(csv, 'goosebumps_' + id + '_' + Date.now() + '.csv');
      showStatus('‚úÖ Exported ' + entry.detections.length + ' detections');
    }
    
    function downloadCSV(csv, filename) {
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }
    
    function showStatus(message) {
      const statusEl = document.getElementById('statusMessage');
      statusEl.textContent = message;
      statusEl.style.display = 'block';
      setTimeout(() => {
        statusEl.style.display = 'none';
      }, 3000);
    }
    
    document.getElementById('resetBaseline').onclick = async () => {
      if (selectedDevice === 'all') {
        const ids = Array.from(deviceCards.keys());
        if (!ids.length) return;
        if (!confirm('Reset baseline for ALL devices?')) return;
        await Promise.all(ids.map(id => fetch('/reset_baseline/' + id, { method: 'POST' })));
        showStatus('‚úÖ Baselines reset');
      } else {
        perDeviceReset(selectedDevice);
      }
    };
    
    document.getElementById('exportData').onclick = () => {
      if (selectedDevice === 'all') {
        const rows = [];
        deviceCards.forEach((entry, id) => {
          entry.detections.forEach(d => rows.push(id + ',' + d.time + ',' + d.frame + ',' + d.intensity));
        });
        if (!rows.length) {
          showStatus('‚ùå No detections');
          return;
        }
        const csv = 'Device,Time,Frame,Intensity\n' + rows.join('\n');
        downloadCSV(csv, 'goosebumps_ALL_' + Date.now() + '.csv');
        showStatus('‚úÖ Exported ' + rows.length + ' detections');
      } else {
        perDeviceExport(selectedDevice);
      }
    };
    
    document.getElementById('clearGraphBtn').onclick = () => {
      liveChart.updateSeries([{ data: [] }]);
      showStatus('‚úÖ Graph cleared');
    };
    
    // Socket event handlers
    socket.on('frame', (data) => {
      console.log('üì• Frame received:', data.device_id, 'Frame:', data.frame_number, 'Intensity:', data.goosebump_intensity);
      
      if (!(selectedDevice === 'all' || data.device_id === selectedDevice)) return;
      
      const entry = buildCard(data.device_id);
      deviceLastActive.set(data.device_id, Date.now());
      
      // Update video overlay for camera feeds
      if (data.device_id.startsWith('mobile-camera-')) {
        const videoInfoOverlay = document.getElementById('videoInfoOverlay');
        if (videoInfoOverlay) {
          const existingDetection = videoInfoOverlay.querySelector('.detection-badge');
          if (data.detect && !existingDetection) {
            const badge = document.createElement('div');
            badge.className = 'detection-badge';
            badge.textContent = 'üéØ Goosebumps! ' + data.goosebump_intensity.toFixed(1) + '%';
            videoInfoOverlay.appendChild(badge);
          } else if (!data.detect && existingDetection) {
            existingDetection.remove();
          } else if (data.detect && existingDetection) {
            existingDetection.textContent = 'üéØ Goosebumps! ' + data.goosebump_intensity.toFixed(1) + '%';
          }
        }
      }
      
      // Update card visibility and status
      entry.root.style.display = 'flex';
      const statusIndicator = entry.root.querySelector('.status-indicator');
      if (statusIndicator) {
        statusIndicator.classList.remove('inactive');
        statusIndicator.classList.add('active');
      }
      
      // Update image
      try {
        entry.img.src = 'data:image/jpeg;base64,' + data.img;
      } catch (e) {
        console.error('Image update error:', e);
      }
      
      // Update overlay
      if (!data.baseline_established) {
        entry.overlay.className = 'feed-overlay baseline';
        entry.overlay.textContent = 'Baseline (Frame: ' + data.frame_number + ')';
      } else if (data.detect) {
        entry.overlay.className = 'feed-overlay detect';
        entry.overlay.textContent = 'üéØ Goosebumps! ' + data.goosebump_intensity.toFixed(1) + '%';
      } else {
        entry.overlay.className = 'feed-overlay monitor';
        entry.overlay.textContent = 'Monitoring (Frame: ' + data.frame_number + ')';
      }
      
      // Update stats
      entry.stats.frames.set(data.frame_number);
      entry.stats.detect.set(data.detection_count);
      entry.stats.power.set(data.current_power.toFixed(2));
      entry.stats.baseline.set(data.baseline_established ? data.baseline_power.toFixed(2) : '...');
      
      // Update charts
      if (data.baseline_established) {
        const newPoint = [data.frame_number, data.goosebump_intensity];
        
        // Update device chart
        try {
          const currentData = entry.chart.w.config.series[0].data;
          const updatedData = [...currentData, newPoint];
          
          // Keep only last 100 points
          if (updatedData.length > 100) {
            updatedData.shift();
          }
          
          entry.chart.updateSeries([{
            data: updatedData
          }], false);
          
          console.log('üìà Updated device chart for', data.device_id, '- Points:', updatedData.length);
        } catch (e) {
          console.error('Device chart update error:', e);
        }
        
        // Update live chart
        try {
          const liveData = liveChart.w.config.series[0].data;
          const updatedLiveData = [...liveData, newPoint];
          
          // Keep only last 150 points
          if (updatedLiveData.length > 150) {
            updatedLiveData.shift();
          }
          
          liveChart.updateSeries([{
            data: updatedLiveData
          }], false);
          
          console.log('üìä Updated live chart - Points:', updatedLiveData.length, 'Value:', data.goosebump_intensity.toFixed(2));
          
          // Show live graph container
          const liveGraphContainer = document.getElementById('liveGraphContainer');
          if (liveGraphContainer && !liveGraphContainer.classList.contains('active')) {
            liveGraphContainer.classList.add('active');
            console.log('‚úÖ Live graph container activated');
          }
        } catch (e) {
          console.error('Live chart update error:', e);
        }
      }
      
      // Track detections
      if (data.detect) {
        entry.detections.push({
          time: data.timestamp,
          intensity: data.goosebump_intensity,
          frame: data.frame_number
        });
        console.log('üéØ Detection recorded:', entry.detections.length, 'total');
      }
      
      applyFilter();
    });
    
    socket.on('devices', (msg) => {
      console.log('üì± Devices update:', msg.devices);
      updateDeviceList(msg.devices || []);
    });
    
    function updateDeviceList(devices) {
      const select = document.getElementById('deviceSelect');
      const current = select.value || 'all';
      select.innerHTML = '<option value="all">All Active Devices</option>';
      
      const activeDeviceIds = new Set();
      devices.forEach(dev => {
        const info = typeof dev === 'object' ? dev : { id: dev };
        const opt = document.createElement('option');
        opt.value = info.id;
        opt.textContent = info.id + ' ' + (info.baseline_ready ? '‚úì' : '‚è≥');
        select.appendChild(opt);
        buildCard(info.id);
        activeDeviceIds.add(info.id);
      });
      
      deviceCards.forEach((entry, id) => {
        if (!activeDeviceIds.has(id)) {
          entry.root.style.display = 'none';
        }
      });
      
      if (current !== 'all' && !activeDeviceIds.has(current)) {
        select.value = 'all';
        selectedDevice = 'all';
      } else {
        select.value = current;
        selectedDevice = current;
      }
      
      applyFilter();
    }
    
    document.getElementById('deviceSelect').addEventListener('change', (e) => {
      selectedDevice = e.target.value || 'all';
      console.log('üîÑ Device filter changed to:', selectedDevice);
      applyFilter();
    });
    
    socket.on('connect', () => {
      console.log('‚úÖ Connected to server');
      showStatus('‚úÖ Connected');
    });
    
    socket.on('disconnect', () => {
      console.log('‚ùå Disconnected from server');
      showStatus('‚ùå Disconnected');
    });
    
    // Fetch initial device list
    fetch('/devices')
      .then(r => r.json())
      .then(d => {
        console.log('üìã Initial devices:', d.devices);
        updateDeviceList(d.devices || []);
      })
      .catch(err => console.error('Device fetch error:', err));
    
    // Camera functionality
    const cameraBtn = document.getElementById('cameraBtn');
    const videoUpload = document.getElementById('videoUpload');
    const videoContainer = document.getElementById('videoContainer');
    const videoElement = document.getElementById('videoElement');
    const closeVideoBtn = document.getElementById('closeVideoBtn');
    const flashlightBtn = document.getElementById('flashlightBtn');
    
    let stream = null;
    let flashlightOn = false;
    
    function setupMediaDevices() {
      if (!window.isSecureContext && !window.location.hostname.includes('railway.app')) {
        console.warn('‚ö†Ô∏è Camera requires secure context');
        if (cameraBtn) {
          cameraBtn.textContent = 'üîí Camera (HTTPS Required)';
          cameraBtn.disabled = true;
        }
        return false;
      }
      
      if (!navigator.mediaDevices) {
        navigator.mediaDevices = {};
      }
      
      if (!navigator.mediaDevices.getUserMedia) {
        const getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
        if (!getUserMedia) return false;
        
        navigator.mediaDevices.getUserMedia = function(constraints) {
          return new Promise((resolve, reject) => {
            getUserMedia.call(navigator, constraints, resolve, reject);
          });
        };
      }
      
      return true;
    }
    
    const mediaDevicesAvailable = setupMediaDevices();
    
    cameraBtn.addEventListener('click', async () => {
      if (!mediaDevicesAvailable) {
        showStatus('‚ùå Camera requires HTTPS');
        return;
      }
      
      if (!navigator.onLine) {
        showStatus('‚ùå Camera unavailable offline');
        return;
      }
      
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(d => d.kind === 'videoinput');
        
        let selectedCamera = null;
        for (const device of videoDevices) {
          const label = device.label.toLowerCase();
          if (label.includes('back') || label.includes('rear') || label.includes('environment')) {
            selectedCamera = device.deviceId;
            break;
          }
        }
        
        const constraints = {
          video: {
            deviceId: selectedCamera ? { exact: selectedCamera } : undefined,
            facingMode: selectedCamera ? undefined : 'environment',
            width: { ideal: 640, max: 1280 },
            height: { ideal: 480, max: 720 },
            frameRate: { ideal: 15, max: 20 }
          }
        };
        
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        videoElement.srcObject = stream;
        videoContainer.classList.add('active');
        
        const track = stream.getVideoTracks()[0];
        const settings = track.getSettings();
        
        const videoInfoOverlay = document.getElementById('videoInfoOverlay');
        videoInfoOverlay.innerHTML = '<div class="video-info">üìπ ' + 
          settings.width + 'x' + settings.height + ' @ ' + settings.frameRate + 'fps</div>';
        
        showStatus('‚úÖ Camera started');
        startProcessingCameraFrames();
        
      } catch (err) {
        console.error('Camera error:', err);
        let errorMessage = '‚ùå Camera error: ' + err.message;
        
        if (err.name === 'NotAllowedError') {
          errorMessage = '‚ùå Camera access denied';
        } else if (err.name === 'NotFoundError') {
          errorMessage = '‚ùå No camera found';
        } else if (err.name === 'NotReadableError') {
          errorMessage = '‚ùå Camera in use';
        }
        
        showStatus(errorMessage);
      }
    });
    
    closeVideoBtn.addEventListener('click', () => {
      stopCamera();
      showStatus('‚úÖ Camera stopped');
    });
    
    flashlightBtn.addEventListener('click', async () => {
      if (!stream) return;
      
      const track = stream.getVideoTracks()[0];
      const capabilities = track.getCapabilities();
      
      if (capabilities.torch) {
        flashlightOn = !flashlightOn;
        try {
          await track.applyConstraints({ advanced: [{ torch: flashlightOn }] });
          flashlightBtn.textContent = flashlightOn ? 'üî¶' : 'üí°';
          showStatus(flashlightOn ? 'üî¶ Flash ON' : 'üí° Flash OFF');
        } catch (err) {
          console.error('Flashlight error:', err);
          showStatus('‚ùå Flash error');
        }
      } else {
        showStatus('‚ùå Flash not supported');
      }
    });
    
    videoUpload.addEventListener('change', async (e) => {
      if (!navigator.onLine) {
        showStatus('‚ùå Upload unavailable offline');
        e.target.value = '';
        return;
      }
      
      const file = e.target.files[0];
      if (file) {
        stopCamera();
        const videoURL = URL.createObjectURL(file);
        videoElement.src = videoURL;
        videoElement.srcObject = null;
        videoContainer.classList.add('active');
        
        videoElement.onloadedmetadata = () => {
          videoElement.play();
          showStatus('‚úÖ Processing video');
          startProcessingVideoFrames();
        };
      }
    });
    
    function stopCamera() {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }
      videoElement.srcObject = null;
      videoElement.src = '';
      videoContainer.classList.remove('active');
    }
    
    function startProcessingCameraFrames() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d', { alpha: false });
      let captureInterval = 200;
      let frameCount = 0;
      let isProcessing = false;
      
      const cameraDeviceId = 'mobile-camera-' + Date.now();
      deviceLastActive.set(cameraDeviceId, Date.now());
      
      const updateCanvasSize = () => {
        const w = videoElement.videoWidth;
        const h = videoElement.videoHeight;
        if (w && h) {
          canvas.width = Math.min(w, 640);
          canvas.height = Math.min(h, 480);
          return true;
        }
        return false;
      };
      
      const captureFrame = () => {
        if (!stream || isProcessing) return;
        isProcessing = true;
        
        try {
          if (frameCount % 60 === 0) updateCanvasSize();
          
          ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
          frameCount++;
          
          canvas.toBlob((blob) => {
            if (!blob) {
              isProcessing = false;
              scheduleNext();
              return;
            }
            
            const reader = new FileReader();
            reader.onloadend = () => {
              const base64data = reader.result.split(',')[1];
              
              fetch('/upload_frame', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  device_id: cameraDeviceId,
                  jpg_b64: base64data,
                  frame_number: frameCount
                })
              })
              .then(r => r.json())
              .then(data => {
                deviceLastActive.set(cameraDeviceId, Date.now());
                console.log('‚úÖ Frame sent:', frameCount);
              })
              .catch(err => console.error('Frame send error:', err))
              .finally(() => {
                isProcessing = false;
                scheduleNext();
              });
            };
            
            reader.onerror = () => {
              isProcessing = false;
              scheduleNext();
            };
            
            reader.readAsDataURL(blob);
          }, 'image/jpeg', 0.7);
          
        } catch (err) {
          console.error('Capture error:', err);
          isProcessing = false;
          scheduleNext();
        }
      };
      
      const scheduleNext = () => {
        if (stream) setTimeout(captureFrame, captureInterval);
      };
      
      videoElement.addEventListener('playing', () => {
        if (updateCanvasSize()) {
          captureFrame();
        } else {
          setTimeout(() => {
            canvas.width = 640;
            canvas.height = 480;
            captureFrame();
          }, 500);
        }
      }, { once: true });
    }
    
    function startProcessingVideoFrames() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const captureInterval = 200;
      let frameCount = 0;
      
      canvas.width = videoElement.videoWidth || 640;
      canvas.height = videoElement.videoHeight || 480;
      
      const videoUploadId = 'video-upload-' + Date.now();
      deviceLastActive.set(videoUploadId, Date.now());
      
      const captureFrame = () => {
        if (videoElement.paused || videoElement.ended) return;
        
        try {
          ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
          frameCount++;
          
          canvas.toBlob((blob) => {
            const reader = new FileReader();
            reader.onloadend = () => {
              const base64data = reader.result.split(',')[1];
              
              fetch('/upload_frame', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  device_id: videoUploadId,
                  jpg_b64: base64data,
                  frame_number: frameCount
                })
              })
              .then(r => r.json())
              .then(data => {
                deviceLastActive.set(videoUploadId, Date.now());
              })
              .catch(err => console.error('Frame send error:', err));
            };
            
            reader.readAsDataURL(blob);
          }, 'image/jpeg', 0.8);
          
          if (!videoElement.paused && !videoElement.ended) {
            setTimeout(captureFrame, captureInterval);
          }
        } catch (err) {
          console.error('Capture error:', err);
          if (!videoElement.paused && !videoElement.ended) {
            setTimeout(captureFrame, captureInterval);
          }
        }
      };
      
      captureFrame();
    }
    
    console.log('‚úÖ Goosebumps Detector initialized');
  </script>
</body>
</html>
